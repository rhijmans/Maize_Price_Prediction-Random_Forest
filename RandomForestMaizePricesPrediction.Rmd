---
title: "RandomForestMaizePricesPrediction"
#author: "Kevin Oluoch"
#date: "4/29/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE) 
```

## Maize price prediction using a random forest model

### 1. Introduction
Maize prices are determined by many factors; In an attempt at predictimng the maize prices in Tanzania, we created a spatial model using maize prices and several price determinat factors, at known locations across the country. The model was subsequently used to make a spatial predict of prices across the country.

This supervised classification model was based on the Random forest algorithm. The Random forest algoritm was developed by Breiman and in this exercise we'll use the "randomForest" library in R which is based on a Fortran code developed by him and Cutler.

### 2. Required Libraries
Load the "randomForest" and "raster"Libraries. We'll use the "raster" library to create and manipulate spatial data:
```{r echo=FALSE}
library(randomForest)
library(raster)
library(rgdal)
library(caret)
```

### 3. Inputs
#### input files
Path to maize prices data
```{r}
maize.price.path <- './TZ_maize_prices_2015.csv'
```
The maize price variable name
```{r}
responce <- "maipkg"
```



Path to prediction rasters folder
```{r}
raster.dir <- "./rasters" 
```

The Prediction variables to use
```{r}
# 
mypredictors <- c("BIO1", "BIO12", "BIO15", "BIO7", "BPP", 
                  "CEC", "CP_mask","CPP", "DCELL", "DFRES", 
                  "DGRES", "DLIGHT", "DOR1", "DOR2", "DOWS", 
                  "DPARK", "DPOP1", "DPOP2", "DSET", "EVI", 
                  "FIRE", "LSTD", "LSTN", "MB1", "MB2", "MB3", 
                  "MB7", "MDEM", "NPPA", "NPPS", "PARA", 
                  "PARV", "PH", "S1VV", "SLOPE", "SND", "SOC",
                  "SWIR1", "SWIR2", "TIM", "WPOP", 
                  "Longitude", "Latitude"
                  )
```


### 4. Get spatial context of Price data
#### Load prices data
```{r }
maize.price <- read.csv(maize.price.path)
```

View the dataset
```{r}
head(maize.price)
```


#### Create spatialPointsDataframe
We need a spatial Points Data frame -a 'spatialPointsDataframe' object in R- with prices data, which will be used to extract training data from prediction rasters. The Maize price locations have coordinates based on [WGS84](https://confluence.qps.nl/qinsy/en/world-geodetic-system-1984-wgs84-29855173.html). 
First, we create a coordinate reference system object in R, for [WGS84](https://confluence.qps.nl/qinsy/en/world-geodetic-system-1984-wgs84-29855173.html) system
```{r}
# wgs84.prj: projection for coordinates in prices csv
wgs84.prj <- CRS("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
```

We then use the object to create a spatial points data frame. The spatial points data frame will have price data in the attribute table.

```{r}
maizeprice <- SpatialPointsDataFrame( data.frame( maize.price$Longitude, maize.price$Latitude ), 
                                     maize.price[, !( names( maize.price ) %in% c('clusterid'))],
                                     proj4string = wgs84.prj 
                                     )
```

The raster data used in this exercise are in the [Lambert azimuthal equal-area projection](https://en.wikipedia.org/wiki/Lambert_azimuthal_equal-area_projection), which is suitable for the exersice because it preserves areas

we create a coordinate reference system object of laea projection
```{r}
laea.prj <- CRS("+proj=laea +lat_0=5 +lon_0=20 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0")
```

Then transform the coordinates to the laea projection
```{r}
maizeprice_laea <- spTransform(maizeprice, laea.prj)
```

Plot the maize price data to see distribution
```{r}
plot(maizeprice, axes=TRUE, pch = 20, col="Red")
```



### 5. Extract training data
#### Create raster stack
Create raster stack with rasters in raster.dir
for each location with maize price data, we'll extract training data. We'll create a raster stack while 
Create a raster stack from the rasters in the directory given. Only rasters with the given cordinate refrence system will be adopted

Set up empty stack to hold rasters and assign the Coordinate refrence system
```{r}
rasterstack <- stack()
crs(rasterstack) <- laea.prj
```

Add the rasters in the folder specified earlier to stack by creating a character vecter of their names the adding them one by one. 
```{r}
# Add the rasters in folder to stack
    rasterlist <- list.files(path = raster.dir, pattern = "*.tif$")
    rasterlist
    
    for (rastername in rasterlist) {
      rasterfile <- raster(file.path(raster.dir, rastername))
      rasterstack <- addLayer(rasterstack, rasterfile)
    }
```



#### Extract training data
Extract the mean value in pixels ta 5 kilometer (5000 meters)-On the ground- radius around maize price points, from raster stack
```{r}
extdata = extract(rasterstack, maizeprice_laea, buffer=5000, small=TRUE, fun = mean) # Takes Time ~ 1HR
```

Add extracted attributes to point data
```{r}
maizepriceatt <- data.frame(cbind(extdata, "Longitude" = maizeprice_laea$Longitude, "Latitude" = maizeprice_laea$Latitude, "maipkg" = maizeprice$maipkg ))
```

View the data
```{r}
head(maizepriceatt)
```

#### Remove entries with missing(NA) values 
To improve accuracy of the model, we'll remove price locations that lack data in any of the rasters. This may be due to lack of data in that area or due to the location falling outside the raster.

```{r}
maizepriceatt <- maizepriceatt[complete.cases(maizepriceatt),]
```


### 6. FIT MODEL
The random forest algorithm works by developing a model- with an optimal number of decision Trees - that will make known predictions from the training data. 

#### Tune the forest
When running the random forest algorithm, we need to declare the optimal number of decision trees the algorithm should create. Too many Trees and the algorim will overfit the model and/or be unable to predict with new data; Too few Trees and the algorim will underfit the model and/or be unable to model the training data.
We use "tuneRF", to get the optimal tree numbers

```{r}
trf <- tuneRF(x=maizepriceatt[, mypredictors],
              y=maizepriceatt[, responce]
              ) 
trf
```

We'll select the minimum number of trees from the optimal numbers given by considering the [Out-of-Bag error.](https://en.wikipedia.org/wiki/Out-of-bag_error)
```{r}
mintree <- trf[which.min(trf[,2]),1]
mintree
```


#### Fit the model
We can then fit a model with the optimal number of trees. (Take a lot of time (~1 hour): Exact time will depend on the computer's RAM processor speed and other running programs)
```{r}
maizerfmodel <- randomForest(x=maizepriceatt[, mypredictors],
                             y=maizepriceatt[, responce],
                             mtry=mintree,importance = TRUE
                             )
```

Whe can view the randomForest object
```{r}
maizerfmodel
```

plot it
```{r}
plot(maizerfmodel)
```

A see the prediction variables in decending order of importance
```{r}
importance(maizerfmodel)
```

or a dotchart of variable importance
```{r}
varImpPlot(maizerfmodel)
```


### 7. Prepare prediction rasters/data
To make a prediction of Maize price in the whole country(Tanzania), We will use the stack of  rasters  from which we extracted training data plus two additional raster of longitude and  latitude - They were also used as prediction variables.

#### Create latitude and longitude rasters
We'll create two rasters: one with the longitude as the cell and the other with latitude as the cell value.
We'll use one raster from the stack as a refrence to ensure the latitude and longitude rasters have the same properties as the rasters in the stack
```{r}
refrenceraster <- rasterstack[[1]]
```


we'll create the latitude and longitude rasters that are inline with the national boundary  in 5 steps.
(step 1). Download the nation (Tanzania) shapefile. 
```{r}
natbnd <- getData('GADM', country='TZA', level=0)
```

(step 2). Transform it to the raster's coordinate system.
```{r}
natbnd_laea <- spTransform(natbnd, laea.prj)
```

(step 3). Rasterise it while adopting the refrence rasters properties
```{r}
natbnd.raster <- rasterize(natbnd_laea, refrenceraster)
```



(step 4). Extract the Latitude and longitude values from the National raster
```{r}
latitudes <- xFromCell(natbnd.raster, 1:length(natbnd.raster))
longitudes <- yFromCell(natbnd.raster, 1:length(natbnd.raster))
```
 


(step 5) Assign the extracted latitude and longitude values to copies of the National raster
```{r}
natbnd.raster.lati <- natbnd.raster.long <- natbnd.raster
values(natbnd.raster.lati) <- latitudes
values(natbnd.raster.long) <- longitudes
```



#### Assemble prediction raster stack
Name the raster cell values
```{r}
names(natbnd.raster.long) <- "Longitude"
names(natbnd.raster.lati) <- "Latitude"
```

Add them to the prediction rasters stack to maintain the order of the predictors with those used in the model
```{r}
predstack <- stack(rasterstack, natbnd.raster.long, natbnd.raster.lati)
```

The prediction variables in the same order
```{r}
names(predstack)
```

### 8. Make predictions
The prediction can be done in two diffrent ways: A spatial prediction and a non-spatial prediction

#### Spatial Prediction
made using the predict
```{r}
spatial.prediction <- raster::predict(predstack, maizerfmodel) # takes a long time!
```

plot prediction
```{r}
plot(spatial.prediction)
```


#### Spatial Prediction
made using the predict
```{r}
# non-spatial prediction and validation
non.spatial.prediction <- stats::predict(maizerfmodel, maizepriceatt[,mypredictors])
```
Evaluate the prediction
```{r}
round( RMSE( non.spatial.prediction,maizepriceatt[, responce] ) )
```

Plot the observed and predicted (non-spatial) values
```{r}
plot(
  maizepriceatt[, responce],
  non.spatial.prediction,
  col = 'blue',
  xlab = 'observed',
  ylab = 'predicted',
  xlim = c(00, 1600),
  ylim = c(00, 1600)
)
```

### 9. Assess the model
By the “pseudo R-squared”: 1 - mse / Var(y).
```{r}
pseudo.Rsq <- mean(maizerfmodel$rsq)
```

By the diffrence between the observed and the predicted values.
```{r}
prediction.diff <- maizepriceatt[,mypredictors] - maizerfmodel$predicted
head(prediction.diff)
```
